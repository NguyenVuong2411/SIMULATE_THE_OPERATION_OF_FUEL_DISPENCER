#include <blynk.h>

/* TODO: SMTP Enabled. The EmailNow() function needs to be
called in the main program when you are ready to send the
email. EmailNow() can be called, for example, on a
pushbutton press or a timer event. Make sure enough time
is given between subsequent emails for the SMTP state
machine to finish processing the previous request. */

void EmailInit(void)
{
	static ROM char server[] = EMAIL_SERVER;
	static ROM char username[] = EMAIL_USERNAME;
	static ROM char password[] = EMAIL_PASSWORD;
	static ROM char to[] = EMAIL_TO;
	static ROM char cc[] = EMAIL_CC;
	static ROM char bcc[] = EMAIL_BCC;
	static ROM char from[] = EMAIL_FROM;
	static ROM char otherHeaders[] = EMAIL_OTHERHEADERS;
	static char subject[] = EMAIL_SUBJECT;
	static char body[] = EMAIL_BODY;

	memset(&SMTPClient, 0, sizeof(SMTPClient));

	SMTPClient.ServerPort = EMAIL_PORT;

	SMTPClient.Server.szROM = server;

	if (strlenpgm(username) && strlenpgm(password))
	{
		SMTPClient.Username = username;
		SMTPClient.Password = password;
	}
	SMTPClient.To.szROM = to;
	if (strlenpgm(cc))
	{
		SMTPClient.CC.szROM = cc;
	}
	if (strlenpgm(bcc))
	{
		SMTPClient.BCC.szROM = bcc;
	}
	SMTPClient.From.szROM = from;
	if (strlenpgm(otherHeaders))
	{
		SMTPClient.OtherHeaders.szROM = otherHeaders;
	}
	SMTPClient.Body.szRAM = body;
	SMTPClient.Subject.szRAM = subject;

	SMTPClient.ROMPointers.Server=1;
	SMTPClient.ROMPointers.Username=1;
	SMTPClient.ROMPointers.Password=1;
	SMTPClient.ROMPointers.To=1;
	SMTPClient.ROMPointers.CC=1;
	SMTPClient.ROMPointers.BCC=1;
	SMTPClient.ROMPointers.From=1;
	SMTPClient.ROMPointers.OtherHeaders=1;
	SMTPClient.ROMPointers.Body=0;
	SMTPClient.ROMPointers.Subject=0;
}

void EmailNow(void)
{
	if (!SMTPBeginUsage())
	{
		SMTPEndUsage();
		SMTPBeginUsage();
	}
	EmailInit();
	SMTPSendMail();
}

int1 g_MyEmailSending = FALSE;

/* TODO: Web server enabled. Server files are added to the /pages
directory. You can modify the contents of the dynamic display fields
at the end of the index.htm file. By default, headings are in the left
column and the dynamic display elements are in the right. The text on
the input buttons can be set by changing the 'value' strings in the
form section. Dynamic display elements can be added or removed from
index.htm and index.xml */
/* TODO: Server files must be built into an MPFS image prior to 
compiling and runing the web server. Running makempfsimg.bat in the
/mpfs directory will create an MPFS image of the files in /pages.
A new MPFS image has to be compiled and re-loaded if a file in
/pages needs to be changed. */

unsigned int8 http_format_char(char* file, char id, char *str, unsigned int8 max_ret)
{
	/* TODO: This is a callback function to the HTTP stack.
	'id' is the char for the dynamic element to be updated.
	For each dynamic element you create, you need to parse
	and save a result to 'str'. *str is where the callback
	function must save the formatting result, and it should
	not store more than max_ret characters to this pointer
	(buffer-overrun protection).
	Example:
	switch(id) {
		case 0x00:
			set_adc_channel(0);
			delay_us(100);
			i=read_adc();
			sprintf(new_str,"0x%X", i);
	.....
	strncpy(str, new_str, max_ret);
	*/

	*str = 0;

	if (id == 0)
	{
			//TODO: Handle dyn0 field and save result to str
	}
	if (id == 1)
	{
			//TODO: Handle dyn1 field and save result to str
	}
	if (id == 2)
	{
			//TODO: Handle dyn2 field and save result to str
	}
	if (id == 3)
	{
			//TODO: Handle dyn3 field and save result to str
	}
	if (id == 4)
	{
			//TODO: Handle dyn4 field and save result to str
	}

	return(strlen(str));
}

void http_exec_cgi(char* file, char *key, char *val)
{
	/* TODO: This is a callback function to the HTTP stack.
	This function is called with each key/value pair read in
	the GET/POST request before any web data is sent to the
	web browser. 'key' matches the name of the field and
	'val' is the value it was changed to.
	Example:
	int8 v = atoi(val);
	if (stricmp(key,led1_key)==0)
		LedSet(0, v);
	*/

}

void IPAddressInit(void)
{
	//IP address of this unit
	MY_IP_BYTE1=MY_DEFAULT_IP_ADDR_BYTE1;
	MY_IP_BYTE2=MY_DEFAULT_IP_ADDR_BYTE2;
	MY_IP_BYTE3=MY_DEFAULT_IP_ADDR_BYTE3;
	MY_IP_BYTE4=MY_DEFAULT_IP_ADDR_BYTE4;

	//network gateway
	MY_GATE_BYTE1=MY_DEFAULT_GATE_BYTE1;
	MY_GATE_BYTE2=MY_DEFAULT_GATE_BYTE2;
	MY_GATE_BYTE3=MY_DEFAULT_GATE_BYTE3;
	MY_GATE_BYTE4=MY_DEFAULT_GATE_BYTE4;

	//subnet mask
	MY_MASK_BYTE1=MY_DEFAULT_MASK_BYTE1;
	MY_MASK_BYTE2=MY_DEFAULT_MASK_BYTE2;
	MY_MASK_BYTE3=MY_DEFAULT_MASK_BYTE3;
	MY_MASK_BYTE4=MY_DEFAULT_MASK_BYTE4;
}

void WIFI_Init(void)
{
	g_WifiChannelListBitmap = 0xFFFF;
	WIFI_region = MY_DEFAULT_REGION;

	strcpy(AppConfig.MySSID, MY_DEFAULT_SSID_NAME);
	AppConfig.SsidLength = strlen(AppConfig.MySSID);

	AppConfig.SecurityMode = MY_DEFAULT_WIFI_SECURITY_MODE;
	AppConfig.WepKeyIndex  = MY_DEFAULT_WEP_KEY_INDEX;
	memset(AppConfig.SecurityKey, 0x00, sizeof(AppConfig.SecurityKey));
	AppConfig.SecurityKeyLength = strlen(AppConfig.SecurityKey);
	AppConfig.networkType = MY_DEFAULT_NETWORK_TYPE;
	WIFI_adhocBehavior = MY_DEFAULT_ADHOC_BEHAVIOR;
	AppConfig.MyMACAddr.v[0] = MCHP_DEFAULT_MAC_ADDRESS_BYTE_1;
	AppConfig.MyMACAddr.v[1] = MCHP_DEFAULT_MAC_ADDRESS_BYTE_2; 
	AppConfig.MyMACAddr.v[2] = MCHP_DEFAULT_MAC_ADDRESS_BYTE_3;
	AppConfig.MyMACAddr.v[3] = MCHP_DEFAULT_MAC_ADDRESS_BYTE_4;
	AppConfig.MyMACAddr.v[4] = MCHP_DEFAULT_MAC_ADDRESS_BYTE_5;
	AppConfig.MyMACAddr.v[5] = MCHP_DEFAULT_MAC_ADDRESS_BYTE_6;
}

void main()
{

	IPAddressInit();
	EmailInit();
	TickInit();
	enable_interrupts(GLOBAL);
	delay_ms(50); //let the tick get a value for seeding rand
	srand(TickGet() * get_timer0()); //seed random value for channel
	WIFI_Init();
	StackInit();


	while(TRUE)
	{

		// TCP/IP code
		StackTask();

		WIFIConnectTask();  //handle connect/reconnect
		MACProcess();
		//don't attempt anything else TCP/IP related if not connected
		if (!IsLinked())
			continue;
		StackApplications();

		/*TODO: Add logic for calling EmailNow(). The EmailNow() function
		starts the SMTP state machine and sends the email. EmailNow() can
		be called, for example, on a pushbutton press or a timer event. */
		if(0)
		{
			g_MyEmailSending = TRUE;
			EmailNow();
		}
		if (g_MyEmailSending && !SMTPIsBusy())
		{
			g_MyEmailSending = FALSE;
			SMTPEndUsage();	// this function returns the success or error status
		}



		//TODO: User Code
	}

}
